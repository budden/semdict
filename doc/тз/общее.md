# Анархический глоссарий с переводом

## Сущности

### Диалект

tlanguage - язык или диалект. Например:
```
English from «Jargon file»
English by dr Node Js Hipster
РЯ от Microsoft
РЯ в 1С
РЯ в Информатике-21
РЯ от Евпатия Коловратова
РЯ от Октября Ленинова
РЯ от Архиправослава Гогенцоллернова
РЯ от Германа Либералова
РЯ из словаря информатики 1970 года
```
Таким образом, диалекты нужны для того, чтобы учесть переводы из разных источников и субкультур, а также создавать новые, не упираясь в необходимость консенсуса.

### Пользователь 

Пользователь системы и автор текстов (sduser)

### Тема 

Служит для облегчения поиска смысла. Пока что каждому смыслу можно назначить только одну тему.

### Смысл (t_sense)

Состоит из обозначаемого слова (например, «оператор») и его конкретного смысла, например, «элемент языка программирования, больший, чем выражение. Т.е. условный оператор, но не сложение» - tsense. Смысл существует независимо от языка и слова и описывается на 
русском языке.

Смысл идентифицируется просто неким числовым кодом. Это требует большой аккуратности для ведения справочника смыслов, и мы не можем убрать это требование аккуратности.

Пример фрагмента tsense
```
1
 тема: ЯП
 текст: Основной, примитивный, элементарный тип данных, например, BOOLEAN

2
 тема: ГПИ (GUI) 
 текст: пространство на форме, на котором можно рисовать

4 
 тема: ЯП
 текст: +, -, *, >> и тому подобное

```
В статье смысла допустимы абзацы, списки ul и гиперссылки. Больше ничего. В будущем наверняка понадобится ещё ужесточить и формализовать требования к смыслу.

### Слово-смысл (t_word_sense)

Устанавливает, что данное слово или словосочетание в определённом диалекте может иметь такой смысл. Например, 
```
смысл 4 в языке Яр может выражаться как «операция»
смысл 2 в английском может выражаться как «canvas»
```
Слово является полем данной сущности. 

## Владение диалектами, смыслами и связями слово-смысл

### Определение понятия владения

- пользователь может явно владеть диалектом, смыслом и связью слово-смысл (есть поле для хранения владельца)
- связь слово-смысл может не иметь владельца, тогда её она неявно принадлежит владельцу диалекта
- всё, у чего нет владельца согласно предыдущим правилам, является общим

### Ограничения и операции над владением

- пользователь может передать свой диалект, смысл и связь слово-смысл другому пользователю
- царь может отобрать любые сущности у пользователя и передать их другому пользователю
- владельцем смысла в диалекте, принадлежащем пользователю, может быть только этот пользователь или царь
- если есть связи слово-смысл для смысла, и их владелец отличается от владельца смысла, то смысл нельзя редактировать

### Нормы управления владением

- смыслы обычно принадлежат царю - это нужно для поддержания самосогласованности таблицы смыслов, а за это отвечает царь. Любой пользователь может добавить смысл, но он должен достаточно быстро передать его царю, или царь должен отобрать его
- общие диалекты, такие, как "английский язык", "русский язык", не имеют владельца и любой пользователь может их исправлять
- индивидуальные "творческие" диалекты, разрабатываемые авторами, принадлежат их авторам, а у смыслов в этих диалектах нет явных владельцев. Царь вмешивается в эти диалекты только при необходимости исправления таблицы смыслов, а также в целях соблюдения законов РФ.

## Дампы базы

Периодически создаются дампы базы. Любой пользователь может загрузить последний дамп. Дамп не содержит секретную информацию пользователей (E-mail и хеш-пароля), но из него можно поднять копию сайта (без возможности редактирования теми же пользователями). Так гарантируется защита от тирании царя, в сочетании с открытостью исходных текстов и наличием документированной процедуры развёртывания системы. 

## Запросы

Как минимум, нужны запросы:

- поиск слова в смыслах и переводах, с настройкой полей, которые нужно искать
- поиск предложений с фильтрацией по слову, пользователю, языку и флагу «предложить владельцу языка».
- поиск диалектов с фильтрацией по предкам, владельцу, названию.

### Технология сохранения запроса

Очевидно, нужно, чтобы можно было сохранить текущий запрос. Предлагается сделать вторую кнопку "сохранить этот запрос". 
Предлагается использовать https://stackoverflow.com/a/547824 - двум формам дать разные имена и обрабатывать сохранение на 
сервере. 
```
<input type="submit" name="button_1" value="Click me">
```

## Нерешённое

### История изменений
По-хорошему нужно, но поначалу можно и без неё. Она более важна для зрелой базы данных, а не на этапе начального заполнения.

### Чем заполнять?
Кроме очевидных предыдущих версий словаря от разных чудаков, где же можно взять смыслы уже в готовом виде? 

Для получения значений нужно брать толковые словари, глоссарии. Например, FIXME можно найти в [файле жаргона](http://www.catb.org/~esr/jargon/html/go01.html)

Правда, и здесь всё не так просто. В разных глоссариях смыслы могут быть очерчены по-разному. Возможно, каждый глоссарий может быть оформлен как отдельный диалект. 

Кодифицировать смыслы можно по принципам RDF или OWL. 

### Реализация системы прав

#### Роли не нужны

Система простая и роли в ней пока что не нужны. Объекты защиты назначаются непосредственно пользователям. 

#### Объекты защиты

Объекты защиты могут ссылаться на сущности в нашей БД, например, на язык. Так, задавая один код объекта защиты, мы
сразу создаём серию объектов защиты, а не один. Известны такие объекты защиты:

- 1 вход в систему (пользователь может быть забанен)
- 2 назначение прав
- 3 редактирование справочника языков
- 4 приём и отклонение запроса на изменения (в конкретном языке)

Таблица объектов защиты не имеет интерфейса, заполняется скриптом. 

#### UI системы прав

Пока что это будет просто набор хранимых процедур, в т.ч. для добавления права и его удаления;
а также отчёт "мои права".

#### БД системы прав

- объекты защиты 'tprivilegekind'
- права, назначенные пользователю (содержит ссылку на язык, к-рая используется не всегда), 'tuserprivilege' 

#### Защита от будущих изменений

С правами получается заморочено, поэтому мы фиксируем только набор функций для проверки прав. Функции будут
примерно такие:

```
ПроверитьПравоНаЯзык(кодПользователя, кодВидаПрава, кодЯзыка)
ПроверитьПраво(кодПользователя, кодВидаПрава)
```

## Prior art

Версия в таблицах google docs, публично доступную копию [можно скачать здесь](https://docs.google.com/spreadsheets/d/1z20rkYFBxX9p3eKwG74fEiuDGcJ1j0ud_spV1JTTe2w/edit?usp=sharing).

Сделано в мире сделано очень много, нужно это использовать. Сразу были отброшены редакторы словарей типа Goldendict - они не подразумевают совместной работы и редактирования отдельных статей. Сейчас я копаюсь в теме обработки естественных языков (ЕЯ) и пытаюсь подобрать тот словарь, который можно было бы взять в качестве источника смыслов. По сути, это должен быть хороший англоязычный глоссарий компьютерных терминов. Далее поток сознания (отчёт о поисковой работе). 

[Семантическая паутина](https://ru.wikipedia.org/wiki/Семантическая_паутина) - вместо слов в этой паутине элементами являются URI. С помощью схемы RDF можно определить набор отношений между элементами (является, владеет и т.п.) и далее на языке RDF описывать семантические отношения между URI. 

Язык RDF - содержит тройки (объект, отношение, объект) из URI. Возможные отношения задаются схемой, их суть не определяется самим языком RDF.

[Язык OWL](https://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/#Translation_of_Axioms_without_Annotations) - язык онтологий для семантического веба. Примеры отношений OWL видны по ссылке в таблице 1:

```
ObjectIntersectionOf( CE1 ... CEn )
ObjectOneOf( a1 ... an )
TransitiveObjectProperty( OPE )
SubAnnotationPropertyOf
```

### Ссылки

Исходные тексты:

- [Цель проекта и исходные тексты](https://github.com/budden/semdict)
- [Устаревшая серверная часть - на node.js](https://bitbucket.org/budden/slovo-ipp)
- [Устаревшая версия клиента на nuxt - отвергнута](https://bitbucket.org/budden/slovo)
- [Устаревший блок авторизации и аутентификации для nuxt - отвергнут](https://github.com/budden/auth-module/commits/dev)
- [Тема на ЛОРе](https://www.linux.org.ru/forum/development/14043753)
