# Для чего это нужно?

Изначально это была попытка создать толковый словарь ИТ с возможностью перевода. 
Из-за нехватки ресурсов он выродился в просто упражнение и "доказательство концепции"
, показывающее, что я могу написать пару строк кода и что я могу продемонстрировать потенциальным работодателям :) 

# Что здесь? 

Существуют функции «Регистрации», сеансы с отслеживанием состояния на основе файлов cookie, которые хранятся в sddb. 
Ключ сеанса используется для аутентификации вошедшего в систему пользователя. Страница регистрации отправляет электронное письмо с подтверждением
регистрации и ключом подтверждения. 

# Технологический стёк

- golang
- pkg/errors
- gin
- html/template
- sqlx
- postgresql
- nginx
- systemd
- VPS
- VS Code
- git

# Безопасность

В настоящее время служба развёрнута на сервере VPS в www.semantic-dict.ru. Сервис работает за пределами nginx. 
Настройка SSL nginx ведётся с помощью [этой статьи](https://habr.com/ru/post/325230/)
и квалифицируется как "А+" в https://www.ssllabs.com/ssltest/ 

Пароли хэшируются и засаливаются. Ключи подтверждения и идентификаторы сеанса генерируются с помощью криптографического RNG.

# Отказоустойчивость

Движок работает как служба systemd. Джин склонен проглатывать каждую панику на границе обработчика запросов, заносить
ее в журнал и продолжать работать. Например, если в транзакции базы данных произошло что-то плохое, например
"не удалось откатить во время обработки паники", есть ли разумный способ продолжить? С текущим стеком библиотек
"обработка" этой ошибки подразумевает просто печать сообщения и игнорирование последствий. В частности, соединение с базой
данных вернется в пул соединений в беспорядочном состоянии, что, очевидно, повлияет на последующую активность. 

Мы использовали более строгий подход к обработке ошибок. Существует набор "известных" ошибок, таких как "неверные учётные данные" или
"неуникальный ключ", которые мы фиксируем и обрабатываем. Всё остальное заставляет службу жаловаться в журнал, а затем завершать работу. Запуск нового экземпляра зависит от systemd. Существует "изящный" выход (мы ждем пару секунд, чтобы позволить http-серверу выйти и вежливо закрыть соединение с базой данных) для некоторых выделенных "полуизвестных" ошибок и "жёсткого" сбоя, когда мы просто вызываем os.Exit() после печати уведомления об ошибке. 

Чтобы реализовать его, нам пришлось переосмыслить рекомендуемый подход к обработке ошибок в golang. Позже мы обнаружили, что наши
идеи очень похожи на мнения, высказанные "профессиональными" разработчиками golang, например: [Паника, как у профессионала](https://hackernoon.com/panic-like-a-pro-89044d5a2d35)

На самом деле мы не запускали эту службу в производстве, поэтому пока неизвестно, насколько успешна наша текущая обработка ошибок,
но мы считаем, что это "правильная вещь", и после некоторой настройки она будет работать нормально. 

